{"meta":{"title":"oncevan的个人小站","subtitle":"","description":"oncevan的个人博客","author":"Evan Chou","url":"https://oncevan/oncevan.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-05-15T11:52:16.680Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"/404.html","permalink":"https://oncevan/oncevan.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-21T09:54:29.050Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"about/index.html","permalink":"https://oncevan/oncevan.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"archives","date":"2020-05-21T14:41:20.000Z","updated":"2020-05-21T14:41:20.249Z","comments":true,"path":"archives/index.html","permalink":"https://oncevan/oncevan.github.io/archives/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-05-15T11:52:16.726Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"books/index.html","permalink":"https://oncevan/oncevan.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-21T08:40:19.000Z","updated":"2020-05-21T15:13:53.400Z","comments":true,"path":"categories/index.html","permalink":"https://oncevan/oncevan.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-15T13:17:21.756Z","updated":"2019-08-01T11:17:12.000Z","comments":false,"path":"repository/index.html","permalink":"https://oncevan/oncevan.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-05-15T11:52:16.745Z","updated":"2019-08-01T11:17:12.000Z","comments":true,"path":"links/index.html","permalink":"https://oncevan/oncevan.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-21T15:12:47.469Z","updated":"2020-05-21T15:12:47.469Z","comments":true,"path":"tags/index.html","permalink":"https://oncevan/oncevan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线程协作","slug":"线程协作","date":"2020-05-15T14:22:13.000Z","updated":"2020-05-21T15:43:53.121Z","comments":true,"path":"2020/05/15/线程协作/","link":"","permalink":"https://oncevan/oncevan.github.io/2020/05/15/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/","excerpt":"1、控制并发流程1.1、什么是控制并发流程控制并发流程的工具类，作用就是帮助我们程序员更容易的让线程之间合作让线程之间相互配合，来满足业务逻辑比如让线程A等待线程B执行完毕后再执行等合作策略","text":"1、控制并发流程1.1、什么是控制并发流程控制并发流程的工具类，作用就是帮助我们程序员更容易的让线程之间合作让线程之间相互配合，来满足业务逻辑比如让线程A等待线程B执行完毕后再执行等合作策略1.2、控制并发流程的工具类CountDownLatch字面解读：倒数门闩例子：购物拼团满人后才能购买；大巴满人发车流程：倒数结束之前，一直处于等待状态，知道倒计时结束了，此流程才继续工作方法CountDownLatch（int count）：仅有这一个构造函数，参数count为需要倒数的数值await()：调用await()方法的线程会被挂起，它会等待知道count值为0才继续执行countDown()：将count值减1，直到为0时，等待的线程会被唤起。典型用法用法一：一个线程等待多个线程都执行完毕，再继续自己的工作用法二：多个线程等待某一个线程的信号，同时开始执行注意点CountDownLatch不可重用（不可回滚重置），也就是说，倒数完成后，不能再次执行倒数。可以考虑使用CyclicBarrier或者创建新的CountDownLatch实例2、信号量SemaphoreSemaphore可以用来限制或管理数量有限的资源的使用情况信号量的作用是维护一个许可证的计数，线程可以“获取”许可证，那信号量剩余的许可证就减一，线程也可以“释放”一个许可证，那信号量的许可证就加一，当信号量所拥有的许可证数量为0，那么下一个还想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证2.1、信号量使用流程初始化Semaphore并指定许可证的数量在需要信号量的代码前加acquire()或者acquireUninterruptibly()方法任务执行结束后，调用release（）来释放许可证2.2、信号量主要方法new Semaphore(int permits,boolean fair):传入许可证的数量，设置是否公平，公平是指遵循先来先得，（一般设置为公平比较合理）acquire:获取许可证，允许中断发生，获得的许可证数量可大一1acquireUninterruptibly:获得许可证，不允许中断发生tryAcquire:和tryLock很像，查看现在是否有空闲的许可证，如果有的话就获取，没有的话也没关系，可以执行别的任务tryAcquire(timeout):和tryAcquire一样，只不过设置了超时的时间release()：归还许可证，用完以后需要归还，最好和获取的许可证数量一致3、CountDownLatch字面解读：倒数门闩例子：购物拼团满人后才能购买；大巴满人发车流程：倒数结束之前，一直处于等待状态，知道倒计时结束了，此流程才继续工作3.1、主要方法CountDownLatch（int count）：仅有这一个构造函数，参数count为需要倒数的数值await()：调用await()方法的线程会被挂起，它会等待知道count值为0才继续执行countDown()：将count值减1，直到为0时，等待的线程会被唤起。3.2、典型用法用法一：一个线程等待多个线程都执行完毕，再继续自己的工作用法二：多个线程等待某一个线程的信号，同时开始执行3.3、注意点CountDownLatch不可重用（不可回滚重置），也就是说，倒数完成后，不能再次执行倒数。可以考虑使用CyclicBarrier或者创建新的CountDownLatch实例4、Condition接口（又称条件对象）4.1、作用当线程1需要等待某个条件才能执行的hi后，他就去执行Condition.await()方法，一旦执行了await()方法，线程就会进入阻塞状态然后通常会有另一个线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就会去执行condition.signal()方法，这时JVM就会从被阻塞的线程里找到那些等待该condition的线程，当线程1就会收到可执行信号的时候，它的线程状态就会变成Runnble可执行状态signalAll()和signal()的区别signalAll()会唤起所有的正在等待的线程但是signal()是公平的，只会唤起哪个等待时间最长的线程4.2、代码演示普通示例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ConditionDemo&#123; private ReentrantLock lock = new ReentrantLock(); private Condition condition = lock.newCondition();//Condition依赖于锁 void method1() throws InterruptException&#123; lock.lock();//获取锁 try&#123; System.out.println(\"条件不满足，开始await\"); condition.await(); System.out.println(\"条件满足了，开始执行后续的任务\"); &#125;finally&#123; lock.unlock(); &#125; &#125; void method2()&#123; lock.lock(); try&#123; System.out.println(\"准备工作完成，唤醒其他的线程\"); condition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args)&#123; ConditionDemo conditionDemo = new ConditonDemo(); new Thread(new Runnable()&#123; @Override public void run()&#123; try&#123; Thread.sleep(1000); conditionDemo.method2(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); conditionDemo.method1();//和Thread的顺序不能变换，换了会一直阻塞在method1 &#125;&#125;/*** 条件不满足，开始await* 准备工作完成，唤醒其他线程* 条件满足了，开始执行后续的任务*/实现消费者生产者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ConditionDemo &#123; private int queueSize = 10; private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(queueSize); private Lock lock = new ReentrantLock(); private Condition notFull = lock.newCondition();//生产者使用 private Condition notEmpty = lock.newCondition();//消费者使用 public static void main(String[] args) &#123; ConditionDemo conditionDemo = new ConditionDemo(); Producer producer = conditionDemo.new Producer(); Consumer consumer = conditionDemo.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread&#123; @Override public void run()&#123; consume(); &#125; //消费者 private void consume()&#123; while (true)&#123; lock.lock(); try&#123; while (queue.size() == 0)&#123; System.out.println(\"队列空，等待数据\"); try &#123; notEmpty.await(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; queue.poll(); notFull.signal(); System.out.println(\"从队列里取走了一条数据，队列剩余\"+queue.size()+\"个元素\"); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; class Producer extends Thread&#123; @Override public void run()&#123; producer(); &#125; //消费者 private void producer()&#123; while (true)&#123; lock.lock(); try&#123; while (queue.size() == queueSize)&#123; System.out.println(\"队列满，等待取出\"); try &#123; notFull.await(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; queue.offer(1); notEmpty.signal(); System.out.println(\"生产一条数据到队列目前有\"+(queueSize-queue.size())+\"个元素\"); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125;&#125;4.3、注意点实际上，如果说Lock用来代替synchronized，那么Condition就是用来代替相对应的Object.wait/notify的（await、signal），所以在用法和性质上，几乎都一样await方法会自动释放持有的Lock锁，和Object.wait一样，不需要自己手动先释放锁调用await的时候，必须持有锁，否则会抛出异常，和Object.wait一样5、CyclicBarrier循环栅栏5.1、作用CyclicBarrier循环栅栏和CountDownLatch很类似，都能阻塞一组线程当大量线程相互配合，分别计算不同任务，并且需要最后统一汇总的时候，我们可以使用CyclicBarrier。CyclicBarrier可以构造一个集结点，当某一个线程执行完毕，它会到集合点等待，直到所有线程都到了集合点，那么该栅栏就会被撤销，所有线程再统一出发，继续执行剩下的任务5.2、代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ConditionDemo &#123; public static void main(String[] args)&#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Runnable() &#123; public void run() &#123; System.out.println(\"所有人都到场了，大家统一出发！\"); &#125; &#125;); //这里的i改成6的话会分为两拨集合 3个一拨，这说明CyclicBarrier是可重用的 for (int i = 0; i &lt; 3; i++) &#123; new Thread(new Task(i,cyclicBarrier)).start(); &#125; &#125; static class Task implements Runnable&#123; private int id; private CyclicBarrier cyclicBarrier; public Task(int id, CyclicBarrier cyclicBarrier) &#123; this.id = id; this.cyclicBarrier = cyclicBarrier; &#125; public void run() &#123; System.out.println(\"线程\"+id+\"前往集合地点\"); try &#123; Thread.sleep((long) (Math.random()*10000)); System.out.println(\"线程\"+id+\"到达集合地点，开始等待其他线程\"); cyclicBarrier.await(); //await下面是集合完以后的操作 //System.out.println(\"线程\"+id+\"出发了\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** 结果如下： * 线程0前往集合地点 * 线程2前往集合地点 * 线程1前往集合地点 * 线程1到达集合地点，开始等待其他线程 * 线程0到达集合地点，开始等待其他线程 * 线程2到达集合地点，开始等待其他线程 * 所有人都到场了，大家统一出发！ */5.3、CyclicBarrier和CountDownLatch的区别作用不同：CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数字到0，也就是说CountDownLatch用于事件，但是CyclicBarrier是用于线程的。可重用性不同：CountDownLatch在倒数到0并触发门闩打开后就不能再次使用了，除非新建新的实例；而CyclicBarrier可以重复使用。CyclicBarrier等线程集合后可以执行统一的工作彩蛋【CountDownLatch与join的区别】https://www.jianshu.com/p/795151ac271b【CountDownLatch】https://www.jianshu.com/p/e233bb37d2e6","categories":[{"name":"多线程与并发","slug":"多线程与并发","permalink":"https://oncevan/oncevan.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"多线程与并发","slug":"多线程与并发","permalink":"https://oncevan/oncevan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"}]},{"title":"并发容器","slug":"并发容器","date":"2020-05-15T13:49:14.000Z","updated":"2020-05-21T15:43:41.355Z","comments":true,"path":"2020/05/15/并发容器/","link":"","permalink":"https://oncevan/oncevan.github.io/2020/05/15/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/","excerpt":"1、并发容器概览ConcurrentHashMap：线程安全的HashMapCopyOnWriteArrayList：线程安全的ListBlockingQueue：这是一个接口，表示阻塞队列，非常适用于作为数据共享的通道ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看做一个线程安全的LinkedListConcurrentSkipListMap：是一个Map，使用跳表的数据结构进行快速查找","text":"1、并发容器概览ConcurrentHashMap：线程安全的HashMapCopyOnWriteArrayList：线程安全的ListBlockingQueue：这是一个接口，表示阻塞队列，非常适用于作为数据共享的通道ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看做一个线程安全的LinkedListConcurrentSkipListMap：是一个Map，使用跳表的数据结构进行快速查找2、同步容器Vector和Hashtable：这两个容器的方法都是使用了synchronized修饰，虽然是线程安全的，但是在多线程的情况下的效率是比较低的ArrayList和HashMap：虽然这两个类不是线程安全的，但是可以用Collections.synchronizedList(new ArrayList&lt;E&gt;())和Collections.synchronizedMap(new HashMap&lt;K,V&gt;())使之变成安全的，但是效率也是不高ConcurrentHashMap和CopyOnWriteArrayList：取代同步的HashMap和同步的ArrayList绝大多数并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能都更好如果一个list经常改动：同步的Arraylist的性能优于CopyOnWriteArrayList，因为CopyOnWriteArrayList适用于读多写少的情况ConcurrentHashMap在任何情况下的性能都要比HashMap或Vector要好3、ConcurrentHashMap3.1、Map简介HashMap：HashMap由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。如果通过hash定位到数组位置没有链表，则查找、添加速度很快。否则，就要解决hash冲突，操作链表。遍历链表时，通过key对象的equals方法逐一比对。构造hashmap的时候有两个参数，initialCapacity初始容量（默认16）、loadFactor装载因子（默认0.75）。向容器中添加元素的时候，如果元素个数达到阈值（元素个数=数组长度*loadFactor），就要自动扩容。使用一个新的数组代替已有的数组，每次扩容为先前的两倍。经过 rehash 之后，元素的位置要么在原位置，要么在原位置再移动2次幂的位置。Hashtable：Hashtable对外提供的public函数几乎都是同步的（synchronized关键字修饰），线程安全。key和value都不能为null。HashTable的数据结构和HashMap一样，采用Entry数组 + 链表的方法实现。HashTabale初始的容量为11，负载因子为0.75，这点和HashMap不同，HashMap初始化时容量大小总是2的幂次方，即使给定一个不是2的幂次方容量的值，也会自动初始化为最接近其2的幂次方的容量。LinkedHashMap：LinkedHashMap保证数据可以保持插入顺序LinkedHashMap在HashMap的基础上多了一个双向链表来维持顺序。TreeMap：TreeMap的数据结构是红黑树。HashMap和Hashtable不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而TreeMap可以按key的大小顺序排序。3.2、为什么需要ConcurrentHashMap为什么HashMap是线程不安全的？同时put碰撞导致数据丢失假设两个线程计算出来的hash值一样，那么两个key会放到同一个位置，导致最终一个数据会丢失同时put扩容导致数据丢失两个线程同时扩容，那么最后也只会保存一个线程中的扩容HashMap死循环造成的CPU100%主要存在于JDK1.7当中，多个线程同时扩容的时候会造成死循环，也就是你指向我我指向你，因为HashMap并不是为了并发情况下设计的JDK1.7的ConcurrentHashMap实现和分析Java 7中的ConcurrentHashMap最外层是多个segment，每个segment的底层数据结构与HashMap类似，仍然是数组和链表组成的拉链法每个segment独立上ReentrantLock锁（重入锁），每个segment之间互不影响，提高了并发效率ConcurrentHashMap默认有16个segemnt，所以最多可以支持16个线程并发写（操作分布在不同的segment上）。这个默认值可以在初始化的时候设置为其他值，但是一旦初始化以后，是不可以扩容的JDK1.8的ConcurrentHashMap实现和分析彩蛋【HashMap和ConcurrentHashMap的扩容机制】https://www.cnblogs.com/lfs2640666960/p/9621461.html【为什么hashMap的容量扩容时一定是2的幂次】https://blog.csdn.net/gududedabai/article/details/85784161","categories":[{"name":"多线程与并发","slug":"多线程与并发","permalink":"https://oncevan/oncevan.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"多线程与并发","slug":"多线程与并发","permalink":"https://oncevan/oncevan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"}]}],"categories":[{"name":"多线程与并发","slug":"多线程与并发","permalink":"https://oncevan/oncevan.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"多线程与并发","slug":"多线程与并发","permalink":"https://oncevan/oncevan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"}]}